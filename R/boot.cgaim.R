#' Boostrap CGAIM
#' 
#' Generates bootstrap replicates of a \code{cgaim} object.
#' 
#' @param object A \code{cgaim} object.
#' @param boot.type The type of bootstrap to perform. Currently
#' available type are \code{"residuals"}, \code{"wild"} and 
#' \code{"pairs"}. See details
#' @param bsamples A numerical matrix of observation indices specifying 
#' bootstrap samples.
#' Rows indicate observations and columns bootstrap samples.
#' If \code{NULL} (the default), samples are generated internally.
#' @param B Number of bootstrap samples to generate when \code{bsamples = NULL}.
#' @param l Block length for block-bootstrap. Samples are generated by
#'    resampling block of observation of length \code{l}. The classical
#'    bootstrap corresponds to \code{l = 1} (the default).
#' @param nc Number of cores to be used for parallel computing.
#' 
#' This function fits \code{cgaim} on bootstrap samples of the original dataset.
#' It is used by the \code{\link{confint.cgaim}} function, but can also be
#' called directly to generate various statistics.
#' 
#' Two types of bootstrap are currently implemented. \code{"residuals"} 
#' (the default) resamples residuals that are added to fitted values by the
#' model. Boostrap replications are then computed by fitting \code{cgaim} 
#' using these newly generated y values with the original x. \code{"wild"} is
#' similar except that residuals are multiplied by a random draws from a
#' standard normal distribution before being added to fitted values. In
#' \code{boot.type = "pairs"} pairs of y and x are resampled to create 
#' bootstrap samples.
#' 
#' Indices for bootstrap samples can either be given by the user through
#' \code{bsamples} or generated internally. In the former case, 
#' the columns of \code{bsamples} indicate the number of replications and
#' the rows should match the original number observations. Internally
#' generated bootstrap samples are controlled by the number of replications
#' \code{B} and block length \code{l} if one wants to use block bootstrap.
#' The latter is particularly recommended for time series data.
#' 
#' As fitting a large number of \code{cgaim} models can be computationally
#' intense, the function can be run in parallel, using the 
#' \code{\link{doParallel}} package. This can be done by setting the
#' argument \code{nc} to a value greater than 1, controlling the number
#' of cores used in parallelization.
#'    
#' @export
boot.cgaim <- function(object, boot.type = c("residuals", "wild", "pairs"), 
  bsamples = NULL, B = 100, l = 1, nc = 1)
{
  # Check boot.type
  boot.type <- match.arg(boot.type)
  
  # Extract useful features
  n <- length(object$fitted)
  
  #----- Get model specifications
  pars <- object$algo_control
  pars$x <- object$x
  pars$index <- object$index
  pars$smooth_control <- object$smooth_control
  pars$alpha_control <- object$alpha_control
  pars$w <- object$weights
  
  #----- Create samples
  if (is.null(bsamples)){
    firstb <- sample(seq_len(n - l + 1), ceiling((n * B) / l), replace = TRUE)
    blocks <- sapply(firstb, function(b) b:(b + l - 1))
    bsamples <- matrix(blocks[seq_len(n * B)], nrow = n, ncol = B)
  } else {
    B <- ncol(bsamples)
  }
  
  #----- Refit on bootstrap samples
  
  # Prepare loop: either parallel or not
  if (nc > 1){
    `%mydo%` <- `%dopar%`
    doParallel::registerDoParallel(cores = nc)
  } else {
    `%mydo%` <- `%do%`
  }
  
  # Loop across samples
  allres <- foreach::foreach(b = seq_len(B), .packages = "cgaim") %mydo% {
    
    # Get sample
    bsamp <- bsamples[,b]
    
    # Get y (and x) values
    if (boot.type == "pairs"){
      pars$y <- object$y[bsamp]
      attr(pars$y, "varname") <- attr(object$y, "varname")
      pars$x <- object$x[bsamp,]
      if (!is.null(pars$smooth_control$Xcov)) pars$smooth_control$Xcov <- 
        pars$smooth_control$Xcov[bsamp,]
      pars$w <- object$w[bsamp]
    } else {
      bres <- object$residuals[bsamp]
      if (boot.type == "wild") bres <- bres * rnorm(n)
      pars$y <- object$fitted + bres
      attributes(pars$y) <- attributes(object$y)
    }
    
    # Fit model
    # ::: for do.call. Necessary within parallelized worker
    fitfun <- get("cgaim.fit", asNamespace("cgaim")) 
    resb <- do.call(fitfun, pars)
    
    # Return
    resb[c("alpha", "beta", "gfit", "indexfit")]
  }
  
  # Stop clusters
  if (nc > 1) doParallel::stopImplicitCluster()
  
  #----- Reshape and return
  
  # Reshape to have each parameter in arrays
  out <- lapply(names(allres[[1]]), 
    function(nm) sapply(allres, "[[", nm, simplify = "array"))
  names(out) <- names(allres[[1]])
  
  # Return
  ans <- list(boot = out, obs = object, 
    samples = bsamples, boot.type = boot.type, B = B, l = l)
  class(ans) <- "boot.cgaim"
  ans
}